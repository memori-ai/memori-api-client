{"version":3,"file":"memori-api-client.cjs.production.min.js","sources":["../src/helpers/getApiUrl.ts","../src/apiFetcher.ts","../src/backend/memori.ts","../src/backend/user.ts","../src/backend/integration.ts","../src/backend/asset.ts","../src/backend/invitation.ts","../src/backend/consumptionLogs.ts","../src/backend/notifications.ts","../src/backend.ts","../src/engine/correlationPairs.ts","../src/engine/dialog.ts","../src/engine/importExport.ts","../src/engine/intents.ts","../src/engine/localizationKeys.ts","../src/engine/media.ts","../src/engine/memories.ts","../src/engine/nlp.ts","../src/engine/people.ts","../src/engine/promptedQuestions.ts","../src/engine/search.ts","../src/engine/session.ts","../src/engine/stats.ts","../src/engine/unansweredQuestions.ts","../src/engine/contextVars.ts","../src/engine/customDictionary.ts","../src/engine/chatLogs.ts","../src/constants.ts","../src/speech.ts","../src/helpers/asset.ts","../src/index.ts","../src/engine.ts"],"sourcesContent":["export const getApiUrl = (hostname?: string) =>\n  hostname\n    ? new URL(\n        hostname.startsWith('http') ? hostname : `https://${hostname}`\n      ).origin.replace('http://', 'https://')\n    : 'https://backend.memori.ai';\n","import { default as fetch } from 'cross-fetch';\n\nexport const apiFetcher = (\n  path: string,\n  opts: {\n    apiUrl: string;\n    method?: string;\n    body?: object;\n    headers?: object;\n    text?: boolean;\n  }\n) =>\n  fetch(`${opts.apiUrl}${path}`, {\n    ...opts,\n    body: opts?.body ? JSON.stringify(opts.body) : undefined,\n    mode: 'cors',\n    credentials: 'include',\n    headers: {\n      // \"Access-Control-Allow-Origin\": \"*\",\n      'Content-Type': 'application/json',\n      ...opts?.headers,\n    },\n  }).then(res => (opts?.text ? res.text() : res.json()));\n","import { ResponseSpec, Memori, MemoriConfig } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\nexport default (apiUrl: string) => ({\n  /**\n   * Gets a list of all the public Memori objects for a specific Tenant.\n   * @param tenant - The name of the tenant\n   * @returns A list of Memori objects\n   */\n  getTenantPublicMemoriList: (tenant: string) =>\n    apiFetcher(`/TenantPublicMemori/${encodeURI(tenant)}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        memori: Memori[];\n      }\n    >,\n\n  /**\n   * Gets a list of all the public Memori objects for a specific Tenant accessible from user session.\n   * @param authToken - The login token\n   * @returns A list of Memori objects\n   */\n  getPublicMemoriList: (authToken: string) =>\n    apiFetcher(`/PublicMemori/${authToken}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        memori: Memori[];\n      }\n    >,\n\n  /**\n   * Gets a list of all Memori objects.\n   * @param authToken - The login token\n   * @returns A list of Memori objects\n   */\n  getAllMemori: (authToken: string) =>\n    apiFetcher(`/AllMemori/${authToken}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        memori: Memori[];\n      }\n    >,\n\n  /**\n   * Gets a list of Memori objects for the currently logged in User.\n   * @param authToken - The login token\n   * @returns A list of Memori objects\n   */\n  getUserMemoriList: (authToken: string) =>\n    apiFetcher(`/Memori/${authToken}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        memori: Memori[];\n      }\n    >,\n\n  /**\n   * Gets a list of Memori objects for the currently logged in User.\n   * @param authToken - The login token\n   * @returns A list of Memori objects\n   */\n  getSharedMemoriList: (authToken: string) =>\n    apiFetcher(`/SharedMemori/${authToken}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        memori: Memori[];\n      }\n    >,\n\n  /**\n   * Gets a list of all the known Memori categories (or tags).\n   * @param {string} tenant - The name of the tenant\n   * @returns A list of Memori categories\n   */\n  getTenantCategories: (tenant: string) =>\n    apiFetcher(`/TenantMemoriCategories/${encodeURI(tenant)}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        memoriCategories: string[];\n      }\n    >,\n\n  /**\n   * Gets a list of all the Memori Configuration objects.\n   * @param authToken - The login token\n   * @returns A list of Memori Configuration objects\n   */\n  getMemoriConfigs: (authToken: string) =>\n    apiFetcher(`/MemoriConfigs/${authToken}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        memoriConfigs: MemoriConfig[];\n      }\n    >,\n\n  /**\n   * Register a new Memori object.\n   * @param authToken - The login token\n   * @param memori - The Memori object\n   * @returns The created Memori object\n   */\n  createMemori: (authToken: string, memori: Memori) =>\n    apiFetcher(`/Memori/${authToken}`, {\n      apiUrl,\n      body: memori,\n      method: 'POST',\n    }) as Promise<ResponseSpec & { memori: Memori }>,\n\n  /**\n   * Update an existing Memori object.\n   * @param authToken - The login token\n   * @param memori - The Memori object\n   * @returns The created Memori object\n   */\n  updateMemori: (\n    authToken: string,\n    memori: Partial<Memori> & { memoriID: string }\n  ) =>\n    apiFetcher(`/Memori/${authToken}/${memori.memoriID}`, {\n      apiUrl,\n      body: memori,\n      method: 'PATCH',\n    }) as Promise<ResponseSpec & { memori: Memori }>,\n\n  /**\n   * Deletes an existing Memori object.\n   * @param authToken - The login token\n   * @param memori - The Memori object\n   */\n  deleteMemori: (authToken: string, memori: Memori) =>\n    apiFetcher(`/Memori/${authToken}`, {\n      apiUrl,\n      body: memori,\n      method: 'DELETE',\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Gets the details of a Memori object of the currently logged in User.\n   * @param authToken - The login token\n   * @param memoriID - The ID of the Memori object\n   * @returns A Memori object\n   */\n  getMemoriById: (authToken: string, memoriID: string) =>\n    apiFetcher(`/Memori/${authToken}/${memoriID}`, {\n      apiUrl,\n    }) as Promise<ResponseSpec & { memori: Memori }>,\n\n  /**\n   * Gets the details of a Memori object of the currently logged in User.\n   * @param {string} tenantName - The Name of the Tenant\n   * @param {string} userID - The ID of the User object\n   * @param {string} memoriID - The ID of the Memori object\n   * @param {string?} authToken - The login token\n   * @returns A Memori object\n   */\n  getMemoriByUserAndId: (\n    tenantName: string,\n    userID: string,\n    memoriID: string,\n    authToken?: string\n  ) =>\n    apiFetcher(\n      `/MemoriById/${tenantName}/${userID}/${memoriID}${\n        authToken ? `/${authToken}` : ''\n      }`,\n      {\n        apiUrl,\n      }\n    ) as Promise<ResponseSpec & { memori: Memori }>,\n\n  /**\n   * Gets the details of a Memori object by name, owner and tenant\n   * @param {string} tenant - The name of the tenant\n   * @param {string} userName - The name of the user\n   * @param {string} memoriName - The name of the Memori object\n   * @param {string=} [authToken=''] - The token of the Memori object\n   */\n  getMemori: (\n    tenant: string,\n    userName: string,\n    memoriName: string,\n    authToken?: string\n  ) =>\n    apiFetcher(\n      `/Memori/${encodeURI(tenant)}/${encodeURI(userName)}/${encodeURI(\n        memoriName\n      )}/${authToken ?? ''}`,\n      {\n        apiUrl,\n      }\n    ) as Promise<ResponseSpec & { memori: Memori }>,\n\n  /**\n   * Gets the statistics for sessions opened in a specified interval for the specified Memori object.\n   * @param {string} authToken - The login token\n   * @param {string} memoriID - The ID of the Memori object\n   * @param {string=} dateFrom - The optional begin of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   * @param {string=} dateTo - The optional end of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   */\n  getMemoriSessions: (\n    authToken: string,\n    memoriID: string,\n    dateFrom?: string,\n    dateTo?: string\n  ) =>\n    apiFetcher(\n      `/MemoriSessions/${authToken}/${memoriID}${\n        dateFrom ? `/${dateFrom}` : ''\n      }${dateFrom && dateTo ? `/${dateTo}` : ''}`,\n      {\n        apiUrl,\n      }\n    ) as Promise<\n      ResponseSpec & {\n        totalSessions: number;\n        validSessions: number;\n      }\n    >,\n\n  /**\n   * Transfers an existing Memori object to another User.\n   * The new owner must be specified by either a OwnerUserID or a OwnerUserName-OwnerTenantName pair.\n   * The OwnerUserName may also specify a user e-mail.\n   * @param {string} authToken - The login token\n   * @param {Memori} memori - The Memori object\n   */\n  transferMemori: (\n    authToken: string,\n    memori: Memori & {\n      ownerTenantName: string;\n      ownerUserName: string;\n    }\n  ) =>\n    apiFetcher(`/TransferMemori/${authToken}`, {\n      apiUrl,\n      body: memori,\n      method: 'POST',\n    }) as Promise<ResponseSpec>,\n});\n","import { ResponseSpec, Tenant, User } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\nexport default (apiUrl: string) => ({\n  /**\n   * Registers a new user.\n   * @param user - The user object\n   * @returns The created user object\n   */\n  userSignIn: (user: User) =>\n    apiFetcher('/User', {\n      apiUrl,\n      body: user,\n      method: 'POST',\n    }) as Promise<ResponseSpec & { user: User }>,\n\n  /**\n   * Confirms the registration of a User and performs a Login.\n   * @param user - The user object\n   * @returns The created user object\n   */\n  userConfirmSignIn: (user: User) =>\n    apiFetcher('/UserConfirm', {\n      apiUrl,\n      body: user,\n      method: 'POST',\n    }) as Promise<ResponseSpec & { user: User; token?: string }>,\n\n  /**\n   * Tries a login with the specified credentials and returns a login token if successful.\n   * @param user - The user object\n   * @returns The logged in user object\n   */\n  userLogin: (user: User) =>\n    apiFetcher('/Login', {\n      apiUrl,\n      body: user,\n      method: 'POST',\n    }) as Promise<\n      ResponseSpec & { user: User; token?: string; flowID?: string }\n    >,\n\n  /**\n   * Logs out the user.\n   * @param authToken - The login token\n   */\n  userLogout: (authToken: string) =>\n    apiFetcher(`/Logout/${authToken}`, {\n      apiUrl,\n      method: 'POST',\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Gets the details of a User object.\n   * @param authToken - The login token\n   * @param userID - The user ID\n   * @returns The user object\n   */\n  getUser: (authToken: string, userID: string) =>\n    apiFetcher(`/User/${authToken}/${userID}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        user: User;\n      }\n    >,\n\n  /**\n   * Gets a list of all the existing User objects.\n   * @param authToken - The login token\n   * @returns A list of User objects\n   */\n  getUsersList: (authToken: string) =>\n    apiFetcher(`/Users/${authToken}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        users: User[];\n      }\n    >,\n\n  /**\n   * Deletes the currently logged in User.\n   * @param {string} authToken - The login token\n   * @param {string} userID: The User ID\n   */\n  deleteUser: (authToken: string, userID: string) =>\n    apiFetcher(`/User/${authToken}/${userID}`, {\n      apiUrl,\n      method: 'DELETE',\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Updates the details of a User object.\n   * @param authToken - The login token\n   * @param userID - The user ID\n   * @returns The user object\n   */\n  updateUser: (authToken: string, userID: string, user: User) =>\n    apiFetcher(`/User/${authToken}/${userID}`, {\n      apiUrl,\n      method: 'PATCH',\n      body: user,\n    }) as Promise<\n      ResponseSpec & {\n        user: User;\n      }\n    >,\n\n  /**\n   * Resets a User's password.\n   * If found, the User receives a verification code via e-mail.\n   * The code must be sent via the ResetConfirm API, passing the same User object\n   * sent to this API with the addition of the verification code and the new password.\n   * @param {User} user - The user object\n   */\n  resetPassword: (user: User) =>\n    apiFetcher(`/ResetPassword`, {\n      apiUrl,\n      body: user,\n      method: 'POST',\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Confirms the password reset of a User and performs a Login\n   * @param {User} user - The user object\n   */\n  resetConfirm: (user: User) =>\n    apiFetcher(`/ResetConfirm`, {\n      apiUrl,\n      body: user,\n      method: 'POST',\n    }) as Promise<\n      ResponseSpec & {\n        user: User;\n        token?: string;\n        flowID?: string;\n      }\n    >,\n\n  /**\n   * Recovers a User's name and sends it to their configured e-mail.\n   * @param {User} user - The user object\n   */\n  recoverUsername: (user: User) =>\n    apiFetcher(`/RecoverUsername`, {\n      apiUrl,\n      body: user,\n      method: 'POST',\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Gets the details of a Tenant object.\n   * @param tenantName - The name of the tenant\n   */\n  getTenantConfig: (tenantName: string) =>\n    apiFetcher(`/Tenant/${tenantName}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        tenant: Tenant;\n      }\n    >,\n\n  /**\n   * Re-sends the verification code to confirm a pending User registration.\n   * @param {User} user - The user object\n   */\n  resendVerificationCode: (user: Partial<User>) =>\n    apiFetcher(`/ResendVerificationCode`, {\n      apiUrl,\n      body: user,\n      method: 'POST',\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Registers a new user.\n   * @param {User} user - The user object\n   */\n  createUser: (authToken: string, user: Partial<User>) =>\n    apiFetcher(`/User/${authToken}`, {\n      apiUrl,\n      body: user,\n      method: 'POST',\n    }) as Promise<ResponseSpec & { user: User }>,\n});\n","import { ResponseSpec, Integration } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\nexport default (apiUrl: string) => ({\n  /**\n   * Gets a list of integration objects for a specified Memori object.\n   * @param memoriID - The id of the Memori object\n   * @param authToken - The login token\n   * @returns A list of Integration objects\n   */\n  getMemoriIntegrationsList: (authToken: string, memoriID: string) =>\n    apiFetcher(`/Integrations/${authToken}/${memoriID}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        integrations: Integration[];\n      }\n    >,\n\n  /**\n   * Gets a list of integration objects.\n   * @param authToken - The login token\n   * @returns A list of Integration objects\n   */\n  getAllIntegrationsList: (authToken: string) =>\n    apiFetcher(`/AllIntegrations/${authToken}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        integrations: Integration[];\n      }\n    >,\n\n  /**\n   * Gets the detail of an integration object of the currently logged in User.\n   * @param authToken - The login token\n   * @param integrationID - The ID of the integration object\n   * @returns The Integration object\n   */\n  getIntegration: (authToken: string, integrationID: string) =>\n    apiFetcher(`/Integration/${authToken}/${integrationID}`, {\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        integration: Integration;\n      }\n    >,\n\n  /**\n   * Delete an exsisting integration object.\n   * @param authToken - The login token\n   * @param integrationID - The ID of the integration object\n   */\n  deleteIntegration: (authToken: string, integrationID: string) =>\n    apiFetcher(`/Integration/${authToken}/${integrationID}`, {\n      apiUrl,\n      method: 'DELETE',\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Register a new integration object.\n   * @param authToken - The login token\n   * @param integration - The Integration object\n   * @returns The Integration object\n   */\n  createIntegration: (authToken: string, integration: Integration) =>\n    apiFetcher(`/Integration/${authToken}`, {\n      apiUrl,\n      method: 'POST',\n      body: integration,\n    }) as Promise<\n      ResponseSpec & {\n        integration: Integration;\n      }\n    >,\n\n  /**\n   * Updates the integration object.\n   * @param authToken - The login token\n   * @param integrationID - The id of the Integration object\n   * @param integration - The Integration object\n   * @returns The Integration object\n   */\n  updateIntegration: (\n    authToken: string,\n    integrationID: string,\n    integration: Integration\n  ) =>\n    apiFetcher(`/Integration/${authToken}/${integrationID}`, {\n      apiUrl,\n      method: 'PATCH',\n      body: integration,\n    }) as Promise<\n      ResponseSpec & {\n        integration: Integration;\n      }\n    >,\n});\n","import { ResponseSpec, Asset } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\nexport default (apiUrl: string) => ({\n  /**\n   * URL to upload a file creating a new Asset object to access it.\n   * @param {string} authToken - The login token\n   * @param {string} memoriID - The memori ID\n   * @param {string=} memoryID - The memory ID\n   * @returns The URL to upload a file\n   */\n  getUploadAssetURL: (authToken: string, memoriID: string, memoryID?: string) =>\n    `${apiUrl}/Asset/${authToken}/${memoriID}${memoryID ? `/${memoryID}` : ''}`,\n\n  /**\n   * Uploads a file and creates a new Asset object to access it.\n   * @param {string} authToken - The login token\n   * @param {string} memoriID - The memori ID\n   * @param {string=} memoryID - The memory ID\n   * @returns Response of an Upload Asset request.\n   */\n  uploadAsset: async (\n    fileName: string,\n    fileUrl: string,\n    authToken: string,\n    memoriID: string,\n    memoryID?: string\n  ) => {\n    const data = new FormData();\n    const file = await fetch(fileUrl);\n    const fileBlob = await file.blob();\n\n    data.append(fileName, fileBlob, fileName);\n\n    const upload = await fetch(\n      `${apiUrl}/Asset/${authToken}/${memoriID}${\n        memoryID ? `/${memoryID}` : ''\n      }`,\n      {\n        method: 'POST',\n        body: data,\n      }\n    );\n    return (await upload.json()) as Promise<\n      ResponseSpec & {\n        asset: Asset;\n      }\n    >;\n  },\n\n  /**\n   * Downloads a file from an Asset object\n   * @param {string} fileName - The file name\n   * @param {string} sessionID - The session ID\n   * @returns The asset file\n   */\n  getAsset: (fileName: string, sessionID: string) =>\n    apiFetcher(`/Asset/${fileName}/${sessionID}`, {\n      apiUrl,\n      method: 'GET',\n    }),\n\n  /**\n   * Updates an Asset object\n   * @param {string} authToken - The login token\n   * @param {string} assetURL - The asset URL\n   * @returns The updated asset object\n   */\n  updateAsset: (authToken: string, assetURL: string, asset: Asset) =>\n    apiFetcher(`/Asset/${authToken}/${assetURL.split('/').reverse()[0]}`, {\n      apiUrl,\n      method: 'PATCH',\n      body: asset,\n    }) as Promise<ResponseSpec & { asset: Asset }>,\n\n  /**\n   * Deletes an Asset object\n   * @param {string} authToken - The login token\n   * @param {string} assetURL - The asset URL\n   */\n  deleteAsset: (authToken: string, assetURL: string) =>\n    apiFetcher(`/Asset/${authToken}/${assetURL.split('/').reverse()[0]}`, {\n      apiUrl,\n      method: 'DELETE',\n    }) as Promise<ResponseSpec>,\n});\n","import { ResponseSpec, Invitation } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\nexport default (apiUrl: string) => ({\n  /**\n   * Gets a list of invitations sent by the currently logged in User.\n   * @param {string} authToken - The login token\n   * @returns The list of Invitation objects.\n   */\n  getSentInvitations: (authToken: string) =>\n    apiFetcher(`/SentInvitations/${authToken}`, {\n      apiUrl,\n    }) as Promise<ResponseSpec & { invitations: Invitation[] }>,\n\n  /**\n   * Gets a list of invitations received by the currently logged in User.\n   * @param {string} authToken - The login token\n   * @returns The list of Invitation objects.\n   */\n  getReceivedInvitations: (authToken: string) =>\n    apiFetcher(`/ReceivedInvitations/${authToken}`, {\n      apiUrl,\n    }) as Promise<ResponseSpec & { invitations: Invitation[] }>,\n\n  /**\n   * Gets a list of all invitation objects\n   * @param {string} authToken - The login token\n   * @returns The list of Invitation objects.\n   */\n  getAllInvitations: (authToken: string) =>\n    apiFetcher(`/AllInvitations/${authToken}`, {\n      apiUrl,\n    }) as Promise<ResponseSpec & { invitations: Invitation[] }>,\n\n  /**\n   * Gets the details of an Invitation object of the currently logged in User.\n   * @param {string} authToken - The login token\n   * @param {string} invitationId - The ID of the Invitation object\n   * @returns The Invitation object.\n   */\n  getInvitation: (authToken: string, invitationId: string) =>\n    apiFetcher(`/Invitation/${authToken}/${invitationId}`, {\n      apiUrl,\n    }) as Promise<ResponseSpec & { invitation: Invitation }>,\n\n  /**\n   * Updates an existing Invitation object sent by the currently logged in User.\n   * @param {string} authToken - The login token\n   * @param {Invitation} invitation - The Invitation object\n   * @returns The Invitation object.\n   */\n  updateInvitation: (\n    authToken: string,\n    invitation: Partial<Omit<Invitation, 'invitationID'>> & {\n      invitationID: string;\n    }\n  ) =>\n    apiFetcher(`/Invitation/${authToken}/${invitation.invitationID}`, {\n      apiUrl,\n      method: 'PATCH',\n      body: invitation,\n    }) as Promise<ResponseSpec & { invitation: Invitation }>,\n\n  /**\n   * Deletes an existing Invitation object.\n   * @param {string} authToken - The login token\n   * @param {string} invitationId - The ID of the Invitation object\n   * @returns The Invitation object.\n   */\n  deleteInvitation: (authToken: string, invitationId: string) =>\n    apiFetcher(`/Invitation/${authToken}/${invitationId}`, {\n      apiUrl,\n      method: 'DELETE',\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Accepts an Invitation object.\n   * @param {string} authToken - The login token\n   * @param {string} invitationId - The ID of the Invitation object\n   * @returns The Invitation object.\n   */\n  acceptInvitation: (authToken: string, invitationId: string) =>\n    apiFetcher(`/AcceptInvitation/${authToken}/${invitationId}`, {\n      apiUrl,\n      method: 'POST',\n    }) as Promise<ResponseSpec & { invitation: Invitation }>,\n\n  /**\n   * Rejects an Invitation object.\n   * @param {string} authToken - The login token\n   * @param {string} invitationId - The ID of the Invitation object\n   * @returns The Invitation object.\n   */\n  rejectInvitation: (authToken: string, invitationId: string) =>\n    apiFetcher(`/RejectInvitation/${authToken}/${invitationId}`, {\n      apiUrl,\n      method: 'POST',\n    }) as Promise<ResponseSpec & { invitation: Invitation }>,\n\n  /**\n   * Send a new Invitation object\n   * @param {string} authToken - The login token\n   * @param {Invitation} invitation - The Invitation object\n   * @returns The Invitation object.\n   */\n  sendInvitation: (\n    authToken: string,\n    invitation: Partial<Omit<Invitation, 'invitationID'>>\n  ) =>\n    apiFetcher(`/SendInvitation/${authToken}`, {\n      apiUrl,\n      method: 'POST',\n      body: invitation,\n    }) as Promise<ResponseSpec & { invitation: Invitation }>,\n});\n","import { ResponseSpec, ConsumptionLog } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\nexport default (apiUrl: string) => ({\n  /**\n   * Gets the Consumption Log objects for a specific Tenant in a specific date interval.\n   * @param {string} authToken - The login token\n   * @param {string} tenantID - The name of the tenant\n   * @param {string} type - Type of consumption (i.e. granularity), it may either be Daily or Monthly\n   * @param {string=} dateFrom - The optional begin of the date interval, in UTC time, in the format yyyyMMdd\n   * @param {string=} dateTo - The optional end of the date interval, in UTC time, in the format yyyyMMdd\n   * @returns The list of Consumption Logs objects.\n   */\n  getTenantConsumptionLogs: (\n    authToken: string,\n    tenantID: string,\n    type: 'Daily' | 'Monthly',\n    dateFrom?: string,\n    dateTo?: string\n  ) =>\n    apiFetcher(\n      `/TenantConsumptionLogs/${authToken}/${tenantID}/${type}${\n        dateFrom ? `/${dateFrom}` : ''\n      }${dateFrom && dateTo ? `/${dateTo}` : ''}`,\n      {\n        apiUrl,\n      }\n    ) as Promise<ResponseSpec & { consumptionLogs: ConsumptionLog[] }>,\n\n  /**\n   * Gets the Consumption Log objects for a specific User in a specific date interval.\n   * @param {string} authToken - The login token\n   * @param {string} userID - The ID of the User object\n   * @param {string} type - Type of consumption (i.e. granularity), it may either be Daily or Monthly\n   * @param {string=} dateFrom - The optional begin of the date interval, in UTC time, in the format yyyyMMdd\n   * @param {string=} dateTo - The optional end of the date interval, in UTC time, in the format yyyyMMdd\n   * @returns The list of Consumption Logs objects.\n   */\n  getUserConsumptionLogs: (\n    authToken: string,\n    userID: string,\n    type: 'Daily' | 'Monthly',\n    dateFrom?: string,\n    dateTo?: string\n  ) =>\n    apiFetcher(\n      `/UserConsumptionLogs/${authToken}/${userID}/${type}${\n        dateFrom ? `/${dateFrom}` : ''\n      }${dateFrom && dateTo ? `/${dateTo}` : ''}`,\n      {\n        apiUrl,\n      }\n    ) as Promise<ResponseSpec & { consumptionLogs: ConsumptionLog[] }>,\n\n  /**\n   * Gets the Consumption Log objects for a specific Memori in a specific date interval.\n   * @param {string} authToken - The login token\n   * @param {string} memoriID - The ID of the Memori object\n   * @param {string} type - Type of consumption (i.e. granularity), it may either be Daily or Monthly\n   * @param {string=} dateFrom - The optional begin of the date interval, in UTC time, in the format yyyyMMdd\n   * @param {string=} dateTo - The optional end of the date interval, in UTC time, in the format yyyyMMdd\n   * @returns The list of Consumption Logs objects.\n   */\n  getMemoriConsumptionLogs: (\n    authToken: string,\n    memoriID: string,\n    type: 'Daily' | 'Monthly',\n    dateFrom?: string,\n    dateTo?: string\n  ) =>\n    apiFetcher(\n      `/MemoriConsumptionLogs/${authToken}/${memoriID}/${type}${\n        dateFrom ? `/${dateFrom}` : ''\n      }${dateFrom && dateTo ? `/${dateTo}` : ''}`,\n      {\n        apiUrl,\n      }\n    ) as Promise<ResponseSpec & { consumptionLogs: ConsumptionLog[] }>,\n});\n","import { ResponseSpec, Notification } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\nexport default (apiUrl: string) => ({\n  /**\n   * Gets the Notification objects available for a specific Tenant.\n   * @param {string} tenantID - The name of the tenant\n   * @returns The list of Notification objects.\n   */\n  getTenantNotifications: (tenantID: string) =>\n    apiFetcher(`/TenantNotifications/${tenantID}`, {\n      apiUrl,\n    }) as Promise<ResponseSpec & { notifications: Notification[] }>,\n\n  /**\n   * Gets the Notification objects available for a specific User.\n   * @param {string} authToken - The login token\n   * @returns The list of Notification objects.\n   */\n  getUserNotifications: (authToken: string) =>\n    apiFetcher(`/UserNotifications/${authToken}`, {\n      apiUrl,\n    }) as Promise<ResponseSpec & { notifications: Notification[] }>,\n});\n","import memori from './backend/memori';\nimport user from './backend/user';\nimport integration from './backend/integration';\nimport asset from './backend/asset';\nimport invitation from './backend/invitation';\nimport consumptionLogs from './backend/consumptionLogs';\nimport notifications from './backend/notifications';\n\nconst backendAPI = (apiUrl: string) => ({\n  asset: asset(apiUrl),\n  memori: memori(apiUrl),\n  user: user(apiUrl),\n  integration: integration(apiUrl),\n  invitation: invitation(apiUrl),\n  consumptionLogs: consumptionLogs(apiUrl),\n  notifications: notifications(apiUrl),\n  ...asset(apiUrl),\n  ...memori(apiUrl),\n  ...user(apiUrl),\n  ...integration(apiUrl),\n  ...invitation(apiUrl),\n  ...consumptionLogs(apiUrl),\n  ...notifications(apiUrl),\n});\n\nexport default backendAPI;\n","import { ResponseSpec } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/****************************\n *                          *\n *     CorrelationPairs     *\n *                          *\n ****************************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Lists all Correlation Pair objects.\n   * @param {string} sessionId The session ID\n   */\n  getCorrelationPairs: async (sessionId: string) =>\n    apiFetcher(`/CorrelationPairs/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Removes an existing Correlation Pair object.\n   * @param {string} sessionId The session ID\n   * @param {string} pairId The Correlation Pair object ID\n   */\n  deleteCorrelationPair: async (sessionId: string, pairId: string) =>\n    apiFetcher(`/CorrelationPair/${sessionId}/${pairId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n});\n","import { DialogState, Medium, ResponseSpec } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/******************\n *                *\n *     Dialog     *\n *                *\n ******************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Submits a Text Entered event to the session's Dialog State Machine.\n   * @param {object} params\n   * @param {string} params.sessionId The session ID\n   * @param {string} params.text The text entered by the user\n   */\n  postTextEnteredEvent: async ({\n    sessionId,\n    text,\n  }: {\n    sessionId: string;\n    text: string;\n  }) =>\n    apiFetcher(`/TextEnteredEvent/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: {\n        text,\n      },\n    }) as Promise<\n      ResponseSpec & {\n        currentState: DialogState;\n      }\n    >,\n\n  /**\n   * Submits a Place Changed event to the session's Dialog State Machine.\n   * @param {object} params\n   * @param {string} params.sessionId - The session ID\n   * @param {string} params.placeName - The name of the place\n   * @param {number} params.latitude - The latitude of the place\n   * @param {number} params.longitude - The longitude of the place\n   * @param {number} params.uncertaintyKm - The uncertainty of the place in kilometers\n   */\n  postPlaceChangedEvent: async ({\n    sessionId,\n    placeName,\n    latitude,\n    longitude,\n    uncertaintyKm,\n  }: {\n    sessionId: string;\n    placeName: string;\n    latitude: number;\n    longitude: number;\n    uncertaintyKm?: number;\n  }) =>\n    apiFetcher(`/PlaceChangedEvent/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: {\n        placeName,\n        latitude,\n        longitude,\n        uncertaintyKm,\n      },\n    }) as Promise<\n      ResponseSpec & {\n        currentState: DialogState;\n      }\n    >,\n\n  /**\n   * Submits a Date Changed event to the session's Dialog State Machine.\n   * @param {string} sessionId The session ID\n   */\n  postDateChangedEvent: async (sessionId: string) =>\n    apiFetcher(`/DateChangedEvent/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Submits a Tag Changed event to the session's Dialog State Machine.\n   * @param {string} sessionId The session ID\n   * @param {string} tag The tag to set\n   */\n  postTagChangedEvent: async (sessionId: string, tag: string) =>\n    apiFetcher(`/TagChangedEvent/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: { tag },\n    }) as Promise<\n      ResponseSpec & {\n        currentState: DialogState;\n      }\n    >,\n\n  /**\n   * Submits a Timeout event to the session's Dialog State Machine.\n   * @param {string} sessionId The session ID\n   */\n  postTimeoutEvent: async (sessionId: string) =>\n    apiFetcher(`/TimeoutEvent/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        currentState: DialogState;\n      }\n    >,\n\n  /**\n   * Submits a Medium Selected event to the session's Dialog State Machine.\n   * @param {string} sessionId The session ID\n   * @param {Medium} medium The medium to set\n   */\n  postMediumSelectedEvent: async (sessionId: string, medium: Medium) =>\n    apiFetcher(`/MediumSelectedEvent/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: { medium },\n    }) as Promise<\n      ResponseSpec & {\n        currentState: DialogState;\n      }\n    >,\n\n  /**\n   * Submits a Date Selected event to the session's Dialog State Machine.\n   * @param {string} sessionId The session ID\n   */\n  postDateSelectedEvent: async (sessionId: string) =>\n    apiFetcher(`/DateSelectedEvent/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Submits a Place Selected event to the session's Dialog State Machine.\n   * @param {string} sessionId The session ID\n   */\n  postPlaceSelectedEvent: async (sessionId: string) =>\n    apiFetcher(`/PlaceSelectedEvent/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Submits a Tag Selected event to the session's Dialog State Machine.\n   * @param {string} sessionId The session ID\n   */\n  postTagSelectedEvent: async (sessionId: string) =>\n    apiFetcher(`/TagSelectedEvent/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n});\n","import { ResponseSpec } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\nexport interface ImportCSVParams {\n  includedRows?: number[];\n  hasHeaders?: boolean;\n  headerNames?: string[];\n  forceImport?: boolean;\n  questionColumnName: string;\n  answerColumnName: string;\n  contextVarsToMatchColumnName?: string;\n  contextVarsToSetColumnName?: string;\n  csvSeparator?: string;\n  questionTitleVariantsSeparator?: string;\n}\n\nexport interface ExportCSVParams {\n  newLine: '\\n' | '\\r\\n';\n  hasHeaders?: boolean;\n  questionColumnName: string;\n  answerColumnName: string;\n  contextVarsToMatchColumnName?: string;\n  contextVarsToSetColumnName?: string;\n  csvSeparator?: string;\n  questionTitleVariantsSeparator?: string;\n}\n\nexport interface ImportReponse {\n  importID: string;\n  importedMemories?: number;\n  importWarnings?: {\n    warningType: 'Existing Similar Memory' | 'Internal Error';\n    rowNumber?: number;\n    csvRow: string;\n    text?: string;\n    similarTexts?: {\n      text: string;\n      similarityLevel: 'HIGH' | 'MEDIUM' | 'LOW';\n    }[];\n  }[];\n}\n\n/************************\n *                      *\n *     ImportExport     *\n *                      *\n ************************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Imports memories from a CSV file.\n   * @param {string} sessionId The session ID\n   * @param {string[]} csvRows Rows of the CSV file.\n   * @param {ImportCSVParams} params The specifications and content of the CSV file\n   */\n  importCSV: async (\n    sessionId: string,\n    csvRows: string[],\n    params: ImportCSVParams\n  ) =>\n    apiFetcher(`/ImportExport/ImportCSV/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: {\n        csvRows,\n        ...params,\n      },\n    }) as Promise<ResponseSpec & ImportReponse>,\n\n  /**\n   * Exports memories to a CSV file.\n   * @param {string} sessionID The session ID\n   * @param {ExportCSVParams} params - The specifications of the CSV file\n   * @returns The CSV file content\n   */\n  exportCSV: async (sessionID: string, params: ExportCSVParams) =>\n    apiFetcher(`/ImportExport/ExportCSV/${sessionID}`, {\n      method: 'POST',\n      apiUrl,\n      body: params,\n      text: true,\n    }) as Promise<string>,\n});\n","import { ResponseSpec, Intent, IntentSlot } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/*******************\n *                 *\n *     Intents     *\n *                 *\n *******************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Lists all Intent objects.\n   * @param {string} sessionId The session ID\n   */\n  getIntents: async (sessionId: string) =>\n    apiFetcher(`/Intents/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        intents: (Intent & { intentID: string })[];\n      }\n    >,\n\n  /**\n   * Gets the details of an Intent object.\n   * @param {string} sessionId The session ID\n   * @param {string} intentId The Intent object ID\n   */\n  getIntent: async (sessionId: string, intentId: string) =>\n    apiFetcher(`/Intent/${sessionId}/${intentId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        intent: Intent & { intentID: string };\n      }\n    >,\n\n  /**\n   * Updates an existing Intent object.\n   * @param {string} sessionId The session ID\n   * @param {Intent} intent The Intent object\n   */\n  patchIntent: async (\n    sessionId: string,\n    intent: Partial<Intent> & { intentID: string }\n  ) =>\n    apiFetcher(`/Intent/${sessionId}/${intent.intentID}`, {\n      method: 'PATCH',\n      apiUrl,\n      body: intent,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Removes an existing Intent object.\n   * @param {string} sessionId The session ID\n   * @param {string} intentId The Intent object ID\n   */\n  deleteIntent: async (sessionId: string, intentId: string) =>\n    apiFetcher(`/Intent/${sessionId}/${intentId}`, {\n      method: 'DELETE',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Adds a new Intent object.\n   * @param {string} sessionId The session ID\n   * @param {Intent} intent The Intent object\n   */\n  createIntent: async (sessionId: string, intent: Intent) =>\n    apiFetcher(`/Intent/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: intent,\n    }) as Promise<\n      ResponseSpec & {\n        intentID: string;\n      }\n    >,\n\n  /**\n   * Lists all Intent Slot objects.\n   * @param {string} sessionId The session ID\n   */\n  getIntentSlots: async (sessionId: string) =>\n    apiFetcher(`/IntentSlots/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        intentSlots: (IntentSlot & {\n          intentSlotID: string;\n        })[];\n      }\n    >,\n\n  /**\n   * Gets the details of an Intent Slot object.\n   * @param {string} sessionId The session ID\n   * @param {string} slotId The Intent Slot object ID\n   */\n  getIntentSlot: async (sessionId: string, slotId: string) =>\n    apiFetcher(`/IntentSlot/${sessionId}/${slotId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        intentSlot: IntentSlot & { intentSlotID: string };\n      }\n    >,\n\n  /**\n   * Updates an existing Intent Slot object.\n   * @param {string} sessionId The session ID\n   * @param {IntentSlot} intentSlot The Intent Slot object\n   */\n  patchIntentSlot: async (\n    sessionId: string,\n    intentSlot: Partial<IntentSlot> & { intentSlotID: string }\n  ) =>\n    apiFetcher(`/IntentSlot/${sessionId}/${intentSlot.intentSlotID}`, {\n      method: 'PATCH',\n      apiUrl,\n      body: intentSlot,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Removes an existing Intent Slot object.\n   * @param {string} sessionId The session ID\n   * @param {string} slotId The Intent Slot object ID\n   */\n  deleteIntentSlot: async (sessionId: string, slotId: string) =>\n    apiFetcher(`/IntentSlot/${sessionId}/${slotId}`, {\n      method: 'DELETE',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Adds a new Intent Slot object.\n   * @param {string} sessionId The session ID\n   */\n  createIntentSlot: async (sessionId: string, intentSlot: IntentSlot) =>\n    apiFetcher(`/IntentSlot/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: intentSlot,\n    }) as Promise<\n      ResponseSpec & {\n        intentSlotID: string;\n      }\n    >,\n});\n","import {\n  ResponseSpec,\n  LocalizationKey,\n  LocalizationKeyContent,\n} from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/****************************\n *                          *\n *     LocalizationKeys     *\n *                          *\n ****************************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Lists all Localizaiton Keys.\n   * @param {string} sessionId The session ID\n   */\n  getLocalizationKeys: async (sessionId: string) =>\n    apiFetcher(`/LocalizationKeys/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        localizationKeys: LocalizationKey[];\n      }\n    >,\n\n  /**\n   * Get an existing Localizaiton Key.\n   * @param {string} sessionId The session ID\n   * @param {string} key The key of the Localization Key\n   */\n  getLocalizationKey: async (sessionId: string, key: string) =>\n    apiFetcher(`/LocalizationKey/${sessionId}/${key}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        localizationKey: LocalizationKey;\n      }\n    >,\n\n  /**\n   * Removes an existing Localizaiton Key. This is only possible if the key is part of\n   *  a key set, where a key set is a set of keys of a common prefix and an index,\n   *  e.g.: <code>INPUT_QUIT_1</code>, <code>INPUT_QUIT_2</code> etc.\n   *  Any index can be specified, the key set will be reordered appropriately.\n   * @param {string} sessionId The session ID\n   * @param {string} key The key of the Localization Key\n   */\n  deleteLocalizationKey: async (sessionId: string, key: string) =>\n    apiFetcher(`/LocalizationKey/${sessionId}/${key}`, {\n      method: 'DELETE',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Add an new Localization Key. This is only possible if the key is part of\n   *  a key set, where a key set is a set of keys of a common prefix and an index,\n   *  e.g.: <code>INPUT_QUIT_1</code>, <code>INPUT_QUIT_2</code> etc.\n   *  Any index can be specified, the key set will be reordered appropriately.\n   * @param {string} sessionId The session ID\n   * @param {LocalizaitonKeyContent} localizationKey Localization Key\n   */\n  postLocalizationKey: async (\n    sessionId: string,\n    localizationKey: LocalizationKeyContent\n  ) =>\n    apiFetcher(`/LocalizationKey/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: localizationKey,\n    }) as Promise<\n      ResponseSpec & {\n        localizationKey: LocalizationKey;\n      }\n    >,\n\n  /**\n   * Updates an existing Localization Key.\n   * @param {string} sessionId The session ID\n   * @param {LocalizationKey} localizationKey Localization Key\n   */\n  patchLocalizationKey: async (\n    sessionId: string,\n    localizationKey: LocalizationKey\n  ) =>\n    apiFetcher(`/LocalizationKey/${sessionId}`, {\n      method: 'PATCH',\n      apiUrl,\n      body: localizationKey,\n    }) as Promise<ResponseSpec>,\n});\n","import { ResponseSpec } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/*****************\n *               *\n *     Media     *\n *               *\n *****************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Lists all Medium objects of a Memory.\n   * @param {string} sessionId The session ID\n   * @param {string} memoryId The Memory object ID\n   */\n  getMedia: async (sessionId: string, memoryId: string) =>\n    apiFetcher(`/Media/${sessionId}/${memoryId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Removes all Medium objects from a Memory.\n   * @param {string} sessionId The session ID\n   * @param {string} memoryId The Memory object ID\n   */\n  deleteMedia: async (sessionId: string, memoryId: string) =>\n    apiFetcher(`/Media/${sessionId}/${memoryId}`, {\n      method: 'DELETE',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Gets the details of a Medium object of a Memory.\n   * @param {string} sessionId The session ID\n   * @param {string} memoryId The Memory object ID\n   * @param {string} mediumId The Medium object ID\n   */\n  getMedium: async (sessionId: string, memoryId: string, mediumId: string) =>\n    apiFetcher(`/Medium/${sessionId}/${memoryId}/${mediumId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Updates an existing Medium object of a Memory.\n   * @param {string} sessionId The session ID\n   * @param {string} memoryId The Memory object ID\n   * @param {string} mediumId The Medium object ID\n   */\n  patchMedium: async (sessionId: string, memoryId: string, mediumId: string) =>\n    apiFetcher(`/Medium/${sessionId}/${memoryId}/${mediumId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Removes an existing Medium object from a Memory.\n   * @param {string} sessionId The session ID\n   * @param {string} memoryId The Memory object ID\n   * @param {string} mediumId The Medium object ID\n   */\n  deleteMedium: (sessionId: string, memoryId: string, mediumId: string) =>\n    apiFetcher(`/Medium/${sessionId}/${memoryId}/${mediumId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Adds a new Medium object to a Memory.\n   * @param {string} sessionId The session ID\n   * @param {string} memoryId The Memory object ID\n   */\n  postMedium: async (sessionId: string, memoryId: string) =>\n    apiFetcher(`/Medium/${sessionId}/${memoryId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n});\n","import { Memory, ResponseSpec } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/********************\n *                  *\n *     Memories     *\n *                  *\n ********************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Lists all Memory objects.\n   * @param {string} sessionId The session ID\n   */\n  getMemories: async (sessionId: string) =>\n    apiFetcher(`/Memories/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        memories: Memory[];\n      }\n    >,\n\n  /**\n   * Lists paginated Memory objects.\n   * @param {string} sessionId The session ID\n   */\n  getMemoriesPaginated: async (\n    sessionId: string,\n    from: number,\n    howMany: number\n  ) =>\n    apiFetcher(`/Memories/${sessionId}/${from}/${howMany}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        count: number;\n        memories: Memory[];\n      }\n    >,\n\n  /**\n   * Gets the details of a Memory object.\n   * @param {string} sessionId The session ID\n   * @param {string} memoryId The Memory object ID\n   */\n  getMemory: async (sessionId: string, memoryId: string) =>\n    apiFetcher(`/Memory/${sessionId}/${memoryId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        memory: Memory;\n      }\n    >,\n\n  /**\n   * Updates an existing Memory object.\n   * @param {string} sessionId The session ID\n   * @param {Memory} memory The Memory object\n   */\n  patchMemory: async (sessionId: string, memory: Memory) =>\n    apiFetcher(`/Memory/${sessionId}/${memory.memoryID}`, {\n      method: 'PATCH',\n      apiUrl,\n      body: memory,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Removes an existing Memory object.\n   * @param {string} sessionId The session ID\n   * @param {string} memoryId The Memory object ID\n   */\n  deleteMemory: async (sessionId: string, memoryId: string) =>\n    apiFetcher(`/Memory/${sessionId}/${memoryId}`, {\n      method: 'DELETE',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Adds a new Memory object.\n   * @param {string} sessionId The session ID\n   * @param {Memory} memory The Memory object\n   */\n  postMemory: async (sessionId: string, memory: Memory) =>\n    apiFetcher(`/Memory/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: memory,\n    }) as Promise<\n      ResponseSpec & {\n        memoryID: string;\n      }\n    >,\n\n  /**\n   * Checks if a Memory object is accessible from the specified session.\n   * @param {string} sessionId The session ID\n   * @param {string} memoryId The Memory object ID\n   */\n  getMemoryAccess: async (sessionId: string, memoryId: string) =>\n    apiFetcher(`/MemoryAccess/${sessionId}/${memoryId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n});\n","import { ResponseSpec } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/***************\n *             *\n *     NLP     *\n *             *\n ***************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Looks up the vector definition for a word.\n   * @param {string} sessionId The session ID\n   * @param {string} word Word to be looked up\n   */\n  getWordVector: async (sessionId: string, word: string) =>\n    apiFetcher(`/WordVector/${sessionId}/${word}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        vector: number[];\n      }\n    >,\n\n  /**\n   * Searches for the 10 words most semantically similar words to the specified word.\n   * @param {string} sessionId The session ID\n   * @param {string} word Word to be looked up\n   */\n  getSimilarWords: async (sessionId: string, word: string) =>\n    apiFetcher(`/SimilarWords/${sessionId}/${word}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        similarWords: string[];\n      }\n    >,\n\n  /**\n   * Tries to guess the language of a sentence by analyzing key word occurrences.\n   * @param {string} sessionId The session ID\n   * @param {string} text Text to be used for guessing the language.\n   */\n  guessLanguage: async (sessionId: string, text: string) =>\n    apiFetcher(`/GuessLanguage/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: { text },\n    }) as Promise<\n      ResponseSpec & {\n        languageGuesses: {\n          [lang: string]: number;\n        };\n      }\n    >,\n\n  /**\n   * Computes the similarity between a reference and a comparison sentences.\n   * @param {string} sessionId The session ID\n   * @param {string} referenceText Text of the reference sentence.\n   * @param {'QUESTION' | 'ANSWER'} referenceTextType Type of reference text, i.e. question or answer. Only types supported are: 'QUESTION' and 'ANSWER'.\n   * @param {string} comparisonText Text of the comparison sentence.\n   * @param {'QUESTION' | 'ANSWER'} comparisonTextType Type of comparison text, i.e. question or answer. Only types supported are: 'QUESTION' and 'ANSWER'.\n   */\n  computeSimilarity: async (\n    sessionId: string,\n    referenceText: string,\n    referenceTextType: 'QUESTION' | 'ANSWER',\n    comparisonText: string,\n    comparisonTextType: 'QUESTION' | 'ANSWER'\n  ) =>\n    apiFetcher(`/ComputeSimilarity/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: {\n        referenceText,\n        referenceTextType,\n        comparisonText,\n        comparisonTextType,\n      },\n    }) as Promise<\n      ResponseSpec & {\n        /**\n         * Similarity index, between 0.0 (totally different) and 1.0 (identical).\n         */\n        similarity: number;\n        /**\n         * Similarity level, i.e. none, low, medium or high.\n         * Currently supported similarity levels are:\n         * NONE, LOW, MEDIUM, HIGH\n         */\n        similarityLevel: 'NONE' | 'LOW' | 'MEDIUM' | 'HIGH';\n      }\n    >,\n\n  /**\n   * Checks the words of a sentence for their definition in the word vector dictionary.\n   * @param {string} sessionId The session ID\n   * @param {string} text Text of the sentence.\n   */\n  checkWords: async (sessionId: string, text: string) =>\n    apiFetcher(`/CheckWords/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: { text },\n    }) as Promise<\n      ResponseSpec & {\n        /**\n         * List of words missing from the word vector dictionary.\n         */\n        undefinedWords: string[];\n      }\n    >,\n});\n","import { ResponseSpec, Person } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/******************\n *                *\n *     People     *\n *                *\n ******************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Lists all Person objects.\n   * @param {string} sessionId The session ID\n   */\n  getPeople: async (sessionId: string) =>\n    apiFetcher(`/People/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        people: Person[];\n      }\n    >,\n\n  /**\n   * Gets the details of a Person object.\n   * @param {string} sessionId The session ID\n   * @param {string} personId The Person object ID\n   */\n  getPerson: async (sessionId: string, personId: string) =>\n    apiFetcher(`/Person/${sessionId}/${personId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        person: Person;\n      }\n    >,\n\n  /**\n   * Updates an existing Person object.\n   * @param {string} sessionId The session ID\n   * @param {Person} person The Person object\n   */\n  patchPerson: async (sessionId: string, person: Person) =>\n    apiFetcher(`/Person/${sessionId}/${person.personID!}`, {\n      method: 'PATCH',\n      body: person,\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        person: Person;\n      }\n    >,\n\n  /**\n   * Removes an existing Person object.\n   * @param {string} sessionId The session ID\n   * @param {string} personId The Person object ID\n   */\n  deletePerson: async (sessionId: string, personId: string) =>\n    apiFetcher(`/Person/${sessionId}/${personId}`, {\n      method: 'DELETE',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Adds a new Person object.\n   * @param {string} sessionId - The session ID\n   * @param {Person} person - The Person object\n   */\n  postPerson: async (sessionId: string, person: Person) =>\n    apiFetcher(`/Person/${sessionId}`, {\n      method: 'POST',\n      body: person,\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        person: Person;\n      }\n    >,\n});\n","import { ResponseSpec } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/*****************************\n *                           *\n *     PromptedQuestions     *\n *                           *\n *****************************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Lists all Prompted Question objects.\n   * @param {string} sessionId The session ID\n   */\n  getPromptedQuestions: async (sessionId: string) =>\n    apiFetcher(`/PromptedQuestions/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Gets the details of a Prompted Question object.\n   * @param {string} sessionId The session ID\n   * @param {string} promptId The Prompted Question object ID\n   */\n  getPromptedQuestion: async (sessionId: string, promptId: string) =>\n    apiFetcher(`/PromptedQuestion/${sessionId}/${promptId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Updates an existing Prompted Question object.\n   * @param {string} sessionId The session ID\n   * @param {string} promptId The Prompted Question object ID\n   */\n  patchPromptedQuestion: async (sessionId: string, promptId: string) =>\n    apiFetcher(`/PromptedQuestion/${sessionId}/${promptId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Removes an existing Prompted Question object.\n   * @param {string} sessionId The session ID\n   * @param {string} promptId The Prompted Question object ID\n   */\n  deletePromptedQuestion: async (sessionId: string, promptId: string) =>\n    apiFetcher(`/PromptedQuestion/${sessionId}/${promptId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Adds a new Prompted Question object.\n   * @param {string} sessionId The session ID\n   */\n  postPromptedQuestion: async (sessionId: string) =>\n    apiFetcher(`/PromptedQuestion/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n});\n","import { ResponseSpec, SearchQuery, SearchMatches } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/******************\n *                *\n *     Search     *\n *                *\n ******************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Searches for matching Memory objects using the same algorithm employed in the Text Entered event of the R1 state of the Dialog State Machine.\n   * @param {string} sessionId The session ID\n   * @param {SearchQuery} query Search query params\n   */\n  searchMemory: async (sessionId: string, query?: SearchQuery) =>\n    apiFetcher(`/Search/${sessionId}`, {\n      method: 'POST',\n      body: query,\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        matches: SearchMatches[];\n      }\n    >,\n\n  /**\n   * Picks up to 5 random Memory objects using the same algorithm employed in the\n   * Timeout event of the R1 state of the Dialog State Machine.\n   * @param {string} sessionId The session ID\n   */\n  postRandom: async (sessionId: string) =>\n    apiFetcher(`/Random/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Picks up to 20 Memory Hint objects, obtained by searching for Story objects with a date or place set,\n   * and clustering dates and places within an uncertainty of at least 1 year or at least 100 km.\n   * Each Memory Hint may either suggest a date or a place, but not both.\n   * @param {string} sessionId The session ID\n   */\n  postHints: async (sessionId: string) =>\n    apiFetcher(`/Hints/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n});\n","import { ResponseSpec, OpenSession, DialogState } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/*******************\n *                 *\n *     Session     *\n *                 *\n *******************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Initializes a new Dialog State Machine session for an existing Memori.\n   */\n  initSession: async (params: OpenSession) =>\n    apiFetcher(`/Session`, {\n      method: 'POST',\n      body: params,\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        sessionID: string;\n        currentState: DialogState;\n      }\n    >,\n\n  /**\n   * Returns the current state of a session's Dialog State Machine.\n   * @param {string} sessionId The session ID\n   */\n  getSession: async (sessionId: string) =>\n    apiFetcher(`/Session/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        currentState: DialogState;\n      }\n    >,\n\n  /**\n   * Closes the session and disposes of its Dialog State Machine.\n   * @param {string} sessionId The session ID\n   */\n  deleteSession: async (sessionId: string) =>\n    apiFetcher(`/Session/${sessionId}`, {\n      method: 'DELETE',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n});\n","import { ResponseSpec, Stats, Memory, EventLog } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/*****************\n *               *\n *     Stats     *\n *               *\n *****************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Computes usage statistics for the Memori of the current session.\n   * @param {string} sessionId The session ID\n   */\n  getStatistics: async (sessionId: string) =>\n    apiFetcher(`/Statistics/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        statistics: Stats;\n      }\n    >,\n\n  /**\n   * Computes content quality indexes for a Memori.\n   * @param {string} memoriID - The Memori object ID\n   */\n  getContentQualityIndexes: async (memoriID: string) =>\n    apiFetcher(`/ContentQualityIndexes/${memoriID}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        /**\n         * @type {number}\n         * An index of content quality of this Memori. The more content is added (and especially content with media, or stories with dates and places) the more the index grows.\n         */\n        contentQualityIndex: number;\n\n        /**\n         * @type {number}\n         * An index of answer quality of this Memori. It is the ratio of the number of successful answer vs. the total of answers (successful, wrongful or missing).\n         */\n        answerQualityIndex: number;\n\n        /**\n         * @type {number}\n         * The current number of unanswered questions.\n         */\n        unansweredQuestions: number;\n      }\n    >,\n\n  /**\n   * Computes text quality indexes for a Memori.\n   * @param {string} sessionId - The session ID\n   */\n  getTextQualityIndexes: async (sessionId: string) =>\n    apiFetcher(`/TextQualityIndexes/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        /**\n         * @type {number}\n         * An index of text quality of this Memori. It is the ratio of the defined words vs. the total of unique words used in question texts and story titles. A value of 1.0 means that no words are undefined, a value of 0.0 means that all words are undefined. Undefined words in a question text or story title have a profound negative impact on the ability to match them with user input.\n         */\n        textQualityIndex: number;\n\n        /**\n         * @type {string[]}\n         * List of undefined words found in question texts and story titles.\n         */\n        undefinedWords: string[];\n\n        /**\n         * @type {number}\n         * An index of text quality of the content of this Memori. It is the ratio of correct question texts and stories titles vs. the total number of question texts and story titles. A value of 1.0 means that all question texts and story titles are correct, a value of 0.0 means that no question text or story title is correct. A question text or story title is defined incorrect (or \"faulty\") if it contains 25% or more of undefined words. Undefined words in a question text or story title have a profound negative impact on the ability to match them with user input.\n         */\n        contentTextQualityIndex: number;\n\n        /**\n         * @type {Memory[]}\n         * List of faulty Memory objects (questions and stories). A question or story is defined as \"faulty\" if it contains at least one undefined word.\n         */\n        faultyMemories?: Memory[];\n      }\n    >,\n\n  /**\n   * Get the Event Log objects for the Memori of the current session in a specific date interval\n   * @param {string} sessionId The session ID\n   * @param {string} strDateFrom The optional begin of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   * @param {string} strDateTo The optional end of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   */\n  getEventLogs: async (\n    sessionId: string,\n    strDateFrom: string,\n    strDateTo: string\n  ) =>\n    apiFetcher(`/EventLogs/${sessionId}/${strDateFrom}/${strDateTo}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        eventLogs: EventLog[];\n      }\n    >,\n\n  /**\n   * Gets the Event Log objects for a specific Memory object in a specific date interval.\n   * @param {string} sessionId - The session ID\n   * @param {string} memoryId - The Memory object ID\n   * @param {string} strDateFrom - The optional begin of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   * @param {string} strDateTo - The optional end of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   */\n  getMemoryEventLogs: async (\n    sessionId: string,\n    memoryId: string,\n    strDateFrom: string,\n    strDateTo: string\n  ) =>\n    apiFetcher(\n      `/EventLogs/${sessionId}/${memoryId}/${strDateFrom}/${strDateTo}`,\n      {\n        method: 'GET',\n        apiUrl,\n      }\n    ) as Promise<\n      ResponseSpec & {\n        eventLogs: EventLog[];\n      }\n    >,\n\n  /**\n   * Gets the Event Log objects for a specific Intent object in a specific date interval.\n   * @param {string} sessionId - The session ID\n   * @param {string} intentId - The Intent object ID\n   * @param {string} strDateFrom - The optional begin of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   * @param {string} strDateTo - The optional end of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   */\n  getIntentEventLogs: async (\n    sessionId: string,\n    intentId: string,\n    strDateFrom: string,\n    strDateTo: string\n  ) =>\n    apiFetcher(\n      `/EventLogs/${sessionId}/${intentId}/${strDateFrom}/${strDateTo}`,\n      {\n        method: 'GET',\n        apiUrl,\n      }\n    ) as Promise<\n      ResponseSpec & {\n        eventLogs: EventLog[];\n      }\n    >,\n});\n","import { ResponseSpec, UnansweredQuestion } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/*******************************\n *                             *\n *     UnansweredQuestions     *\n *                             *\n *******************************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Lists all Unanswered Question objects.\n   * @param {string} sessionId The session ID\n   */\n  getUnansweredQuestions: async (sessionId: string) =>\n    apiFetcher(`/UnansweredQuestions/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        unansweredQuestions: UnansweredQuestion[];\n      }\n    >,\n\n  /**\n   * Lists paginated Unanswered Question objects.\n   * @param {string} sessionId The session ID\n   */\n  getUnansweredQuestionsPaginated: async (\n    sessionId: string,\n    from: number,\n    howMany: number\n  ) =>\n    apiFetcher(`/UnansweredQuestions/${sessionId}/${from}/${howMany}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        count: number;\n        unansweredQuestions: UnansweredQuestion[];\n      }\n    >,\n\n  /**\n   * Removes an existing Unanswered Question object.\n   * @param {string} sessionId The session ID\n   * @param {string} unansweredQuestionId The Unanswered Question object ID\n   */\n  deleteUnansweredQuestion: async (\n    sessionId: string,\n    unansweredQuestionId: string\n  ) =>\n    apiFetcher(`/UnansweredQuestion/${sessionId}/${unansweredQuestionId}`, {\n      method: 'DELETE',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n});\n","import { ResponseSpec } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/****************************\n *                          *\n *       ContextVars        *\n *                          *\n ****************************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Gets a list of currently known context variables.\n   * @param {string} sessionId The session ID\n   */\n  getContextVars: async (sessionId: string) =>\n    apiFetcher(`/ContextVars/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        [variable: string]: string[];\n      }\n    >,\n\n  /**\n   * Gets a list of currently known context variable names.\n   * @param {string} sessionId The session ID\n   */\n  getContextVarNames: async (sessionId: string) =>\n    apiFetcher(`/ContextVarNames/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        contextVarNames: string[];\n      }\n    >,\n\n  /**\n   * /memori/v2/ContextVarValues/{strSessionID}/{contextVarName}\n   * @param {string} sessionId The session ID\n   * @param {string} contextVarName The name of the context variable\n   */\n  getContextVarValues: async (sessionId: string, contextVarName: string) =>\n    apiFetcher(`/ContextVarValues/${sessionId}/${contextVarName}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        contextVarName: string;\n        contextVarValues: string[];\n      }\n    >,\n});\n","import { ResponseSpec, CustomWord } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/****************************\n *                          *\n *     CustomDictionary     *\n *                          *\n ****************************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Lists all Custom Words.\n   * @param {string} sessionId The session ID\n   */\n  getCustomWords: async (sessionId: string) =>\n    apiFetcher(`/CustomWords/${sessionId}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        customWords: CustomWord[];\n      }\n    >,\n\n  /**\n   * Gets the details of a Custom Word object.\n   * @param {string} sessionId The session ID\n   * @param {string} customWordID The Custom Word object ID\n   */\n  getCustomWord: async (sessionId: string, customWordID: string) =>\n    apiFetcher(`/CustomWord/${sessionId}/${customWordID}`, {\n      method: 'GET',\n      apiUrl,\n    }) as Promise<\n      ResponseSpec & {\n        customWord: CustomWord;\n      }\n    >,\n\n  /**\n   * Removes an existing Custom Word object.\n   * @param {string} sessionId The session ID\n   * @param {string} key The key of the Custom Word\n   */\n  deleteCustomWord: async (sessionId: string, key: string) =>\n    apiFetcher(`/CustomWord/${sessionId}/${key}`, {\n      method: 'DELETE',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n\n  /**\n   * Adds a new Custom Word object.\n   * @param {string} sessionId The session ID\n   * @param {CustomWord} customWord Custom Word\n   */\n  postCustomWord: async (\n    sessionId: string,\n    customWord: Pick<CustomWord, 'word'> & Pick<CustomWord, 'definition'>\n  ) =>\n    apiFetcher(`/CustomWord/${sessionId}`, {\n      method: 'POST',\n      apiUrl,\n      body: customWord,\n    }) as Promise<\n      ResponseSpec & {\n        customWord: CustomWord;\n      }\n    >,\n\n  /**\n   * Updates an existing Custom Word object.\n   * Only the Definition field is considered for update. To change the Word field a new Custom Word must be added and the existing must be removed.\n   * @param {string} sessionId The session ID\n   * @param {CustomWord} customWord Custom Word\n   */\n  patchCustomWord: async (\n    sessionId: string,\n    customWord: Partial<CustomWord> & { customWordID: string }\n  ) =>\n    apiFetcher(`/CustomWord/${sessionId}/${customWord.customWordID}`, {\n      method: 'PATCH',\n      apiUrl,\n      body: customWord,\n    }) as Promise<ResponseSpec>,\n});\n","import { ChatLog, ResponseSpec } from '../types';\nimport { apiFetcher } from '../apiFetcher';\n\n/*************************\n *                       *\n *       ChatLogs        *\n *                       *\n *************************/\n\nexport default (apiUrl: string) => ({\n  /**\n   * Gets the Chat Log objects for the Memori of the current session in a specific date interval.\n   * @param {string} sessionId The session ID\n   * @param {?string} dateFrom The optional begin of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   * @param {?string} dateTo The optional end of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   */\n  getChatLogs: async (sessionId: string, dateFrom?: string, dateTo?: string) =>\n    apiFetcher(\n      `/ChatLogs/${sessionId}${dateFrom ? `/${dateFrom}` : ''}${\n        dateFrom && dateTo ? `/${dateTo}` : ''\n      }`,\n      {\n        method: 'GET',\n        apiUrl,\n      }\n    ) as Promise<\n      ResponseSpec & {\n        chatLogs: ChatLog[];\n      }\n    >,\n\n  /**\n   * Removes all Chat Log objects in a specific date internval.\n   * @param {string} sessionId The session ID\n   * @param {?string} dateFrom The optional begin of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   * @param {?string} dateTo The optional end of the date interval, in UTC time, in the format yyyyMMddHHmmssfff\n   */\n  deleteChatLogs: async (\n    sessionId: string,\n    dateFrom?: string,\n    dateTo?: string\n  ) =>\n    apiFetcher(\n      `/ChatLogs/${sessionId}${dateFrom ? `/${dateFrom}` : ''}${\n        dateFrom && dateTo ? `/${dateTo}` : ''\n      }`,\n      {\n        method: 'DELETE',\n        apiUrl,\n      }\n    ) as Promise<ResponseSpec>,\n\n  /**\n   * Removes an existing Chat Log object.\n   * @param {string} sessionId The session ID\n   * @param {string} chatLogId The Chat Log object ID\n   */\n  deleteChatLog: async (sessionId: string, chatLogId: string) =>\n    apiFetcher(`/ChatLog/${sessionId}/${chatLogId}`, {\n      method: 'DELETE',\n      apiUrl,\n    }) as Promise<ResponseSpec>,\n});\n","export const allowedMediaTypes = [\n  'image/jpeg',\n  'image/png',\n  'image/jpg',\n  'image/gif',\n  'text/plain',\n  'application/msword',\n  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  'application/vnd.ms-excel',\n  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n  'application/pdf',\n  'video/mp4',\n  'video/avi',\n  'audio/mpeg3',\n  'audio/wav',\n  'audio/mpeg',\n  'video/mpeg',\n  'model/gltf-binary',\n];\n\nexport const anonTag = '👤';\n","import * as speechSdk from 'microsoft-cognitiveservices-speech-sdk';\n\nconst getTTSVoice = (lang: string, voiceType: 'MALE' | 'FEMALE'): string => {\n  let voice = '';\n  let voiceLang = lang.toUpperCase();\n  switch (voiceLang) {\n    case 'IT':\n      voice = `${\n        voiceType === 'MALE' ? 'it-IT-DiegoNeural' : 'it-IT-ElsaNeural'\n      }`;\n      break;\n    case 'DE':\n      voice = `${\n        voiceType === 'MALE' ? 'de-DE-ConradNeural' : 'de-DE-KatjaNeural'\n      }`;\n      break;\n    case 'EN':\n      voice = `${\n        voiceType === 'MALE' ? 'en-GB-RyanNeural' : 'en-GB-SoniaNeural'\n      }`;\n      break;\n    case 'ES':\n      voice = `${\n        voiceType === 'MALE' ? 'es-ES-AlvaroNeural' : 'es-ES-ElviraNeural'\n      }`;\n      break;\n    case 'FR':\n      voice = `${\n        voiceType === 'MALE' ? 'fr-FR-HenriNeural' : 'fr-FR-DeniseNeural'\n      }`;\n      break;\n    case 'PT':\n      voice = `${\n        voiceType === 'MALE' ? 'pt-PT-DuarteNeural' : 'pt-PT-RaquelNeural'\n      }`;\n      break;\n    default:\n      voice = `${\n        voiceType === 'MALE' ? 'it-IT-DiegoNeural' : 'it-IT-IsabellaNeural'\n      }`;\n      break;\n  }\n  return voice;\n};\n\nconst getCultureCodeByLanguage = (lang: string): string => {\n  let voice = '';\n  let voiceLang = lang.toUpperCase();\n  switch (voiceLang) {\n    case 'IT':\n      voice = 'it-IT';\n      break;\n    case 'DE':\n      voice = 'de-DE';\n      break;\n    case 'EN':\n      voice = 'en-US';\n      break;\n    case 'ES':\n      voice = 'es-ES';\n      break;\n    case 'FR':\n      voice = 'fr-FR';\n      break;\n    case 'PT':\n      voice = 'pt-PT';\n      break;\n    default:\n      voice = 'it-IT';\n      break;\n  }\n  return voice;\n};\n\n/**\n * EXPERIMENTAL\n */\nconst speech = (AZURE_COGNITIVE_SERVICES_TTS_KEY: string, DEBUG = false) => (\n  lang: string,\n  voiceType: 'FEMALE' | 'MALE'\n) => {\n  let speechConfig: speechSdk.SpeechConfig = speechSdk.SpeechConfig.fromSubscription(\n    AZURE_COGNITIVE_SERVICES_TTS_KEY,\n    'eastus'\n  );\n  let speechSynthesizer: speechSdk.SpeechSynthesizer | null;\n  let audioDestination: speechSdk.SpeakerAudioDestination;\n\n  audioDestination = new speechSdk.SpeakerAudioDestination();\n  let audioOutputConfig = speechSdk.AudioConfig.fromSpeakerOutput(\n    audioDestination\n  );\n\n  // https://docs.microsoft.com/it-it/azure/cognitive-services/speech-service/language-support#text-to-speech\n  speechConfig.speechSynthesisVoiceName = getTTSVoice(lang, voiceType);\n\n  let langCultureCode = getCultureCodeByLanguage(lang);\n  speechConfig.speechSynthesisLanguage = langCultureCode;\n  speechConfig.speechRecognitionLanguage = langCultureCode;\n\n  /**\n   * speak\n   * @description Speaks the text using the speech synthesizer. (TTS)\n   * @param {string} text - The text to be synthesized.\n   * @param {func=} onAudioEnd - The callback to be invoked when the synthesized audio is finished.\n   */\n  const speak = (\n    text: string,\n    onAudioEnd?: (sender: speechSdk.IPlayer) => void\n  ) => {\n    stopSpeaking();\n\n    speechSynthesizer = new speechSdk.SpeechSynthesizer(\n      speechConfig,\n      audioOutputConfig\n    );\n\n    if (onAudioEnd) audioDestination.onAudioEnd = onAudioEnd;\n\n    speechSynthesizer.speakTextAsync(\n      text,\n      result => {\n        if (result) {\n          try {\n            if (DEBUG) console.log('speak result', result);\n            if (speechSynthesizer) {\n              speechSynthesizer.close();\n              speechSynthesizer = null;\n            }\n          } catch (e) {\n            console.error('speak error: ', e);\n            window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n          }\n        } else if (DEBUG) {\n          console.log('speak no result', result);\n        }\n      },\n      error => {\n        console.error('speak:', error);\n        window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n      }\n    );\n  };\n\n  /**\n   * isSpeaking\n   * @description Returns true if the synthesizer is speaking.\n   * @returns {boolean}\n   */\n  const isSpeaking = (): boolean => {\n    return !!speechSynthesizer;\n  };\n\n  /**\n   * stopSpeaking\n   * @description Stops the speech synthesizer if it is synthesizing.\n   */\n  const stopSpeaking = () => {\n    if (audioDestination) audioDestination.pause();\n    if (speechSynthesizer) {\n      speechSynthesizer.close();\n      speechSynthesizer = null;\n    }\n  };\n\n  const audioInputConfig = speechSdk.AudioConfig.fromDefaultMicrophoneInput();\n  let recognizer: speechSdk.SpeechRecognizer | null;\n\n  /**\n   * recognize\n   * @description Starts the speech recognition.\n   * @param {func=} onRecognized - Callback method invoked when the speech is recognized with the text.\n   */\n  const recognize = (onRecognized: (transcript: string) => void) => {\n    recognizer = new speechSdk.SpeechRecognizer(speechConfig, audioInputConfig);\n\n    recognizer.recognizing = (_s, e) => {\n      if (DEBUG) console.log(`RECOGNIZING: Text=${e.result.text}`);\n    };\n    recognizer.recognized = (_s, e) => {\n      if (e.result.reason === speechSdk.ResultReason.RecognizedSpeech) {\n        if (DEBUG) console.log(`RECOGNIZED: Text=${e.result.text}`);\n        onRecognized(e.result.text ?? '');\n      } else if (e.result.reason === speechSdk.ResultReason.NoMatch && DEBUG) {\n        console.log('NOMATCH: Speech could not be recognized.');\n      }\n    };\n    recognizer.canceled = (_s, e) => {\n      if (DEBUG) console.log(`CANCELED: Reason=${e.reason}`);\n\n      if (e.reason === speechSdk.CancellationReason.Error && DEBUG) {\n        console.log(`\"CANCELED: ErrorCode=${e.errorCode}`);\n        console.log(`\"CANCELED: ErrorDetails=${e.errorDetails}`);\n        console.log(\n          'CANCELED: Did you set the speech resource key and region values?'\n        );\n      }\n\n      stopRecognizing();\n    };\n\n    recognizer.sessionStopped = (_s, _e) => {\n      if (DEBUG) console.log('\\n    Session stopped event.');\n      if (recognizer) recognizer.stopContinuousRecognitionAsync();\n    };\n    recognizer.startContinuousRecognitionAsync();\n  };\n\n  /**\n   * isRecognizing\n   * @description Returns true if the recognizer is recognizing.\n   * @returns {boolean}\n   */\n  const isRecognizing = (): boolean => {\n    return !!recognizer;\n  };\n\n  /**\n   * stopRecognizing\n   * @description Stops the speech recognizer if it is recognizing.\n   * @param {func=} onStop - (optional) The callback to be invoked when the speech recognition is stopped.\n   */\n  const stopRecognizing = (onStop?: () => void) => {\n    if (recognizer) {\n      recognizer.stopContinuousRecognitionAsync();\n      recognizer.close();\n      recognizer = null;\n\n      if (onStop) onStop();\n    }\n  };\n\n  return {\n    speak,\n    isSpeaking,\n    stopSpeaking,\n    recognize,\n    isRecognizing,\n    stopRecognizing,\n  };\n};\n\nexport default speech;\n","export interface ResourceURLParams {\n  type?: 'avatar' | 'cover' | 'default';\n  resourceURI?: string;\n  sessionID?: string;\n  baseURL?: string;\n}\n\nexport default (apiUrl: string) => ({\n  /**\n   * getResourceUrl\n   * @description Returns the correct URL of a resource from the DB.\n   * @param {obj} params\n   * @param {string=} params.type - wheather is the avatar or the cover\n   * @param {string=} params.resourceURI - the resource URI\n   * @param {string=} params.sessionID - the session ID, required for memory media attachments\n   * @param {string=} params.baseURL - the base URL for default static assets (defaults to https://app.twincreator.com)\n   * @returns {string}\n   */\n  getResourceUrl: ({\n    type,\n    resourceURI,\n    sessionID,\n    baseURL = 'https://app.twincreator.com',\n  }: ResourceURLParams): string => {\n    let defaultUri =\n      type === 'cover'\n        ? `${baseURL}/images/memoriCover.png`\n        : `${baseURL}/images/memoriAvatar.png`;\n    if (!resourceURI || resourceURI.length === 0) {\n      return defaultUri;\n    } else if (resourceURI.includes('memoriai/memory')) {\n      return `${resourceURI}?memori-ai-session-id=${sessionID}`;\n    } else if (\n      resourceURI.startsWith('https://') ||\n      resourceURI.startsWith('http://')\n    ) {\n      return `${resourceURI}${sessionID ? `/${sessionID}` : ''}`;\n    } else if (resourceURI.startsWith('cloud://')) {\n      return `${apiUrl.replace(/v2/, 'v1')}/CloudAsset/${resourceURI.replace(\n        'cloud://',\n        ''\n      )}`;\n    } else if (resourceURI.startsWith('guid://')) {\n      return `${apiUrl.replace(/v2/, 'v1')}/GuidAsset/${resourceURI.replace(\n        'guid://',\n        ''\n      )}`;\n    } else {\n      return defaultUri;\n    }\n  },\n});\n","import { getApiUrl } from './helpers/getApiUrl';\nimport backend from './backend';\nimport engine from './engine';\nimport * as constants from './constants';\nimport speech from './speech';\nimport asset from './helpers/asset';\n\nconst api = (hostname?: string) => {\n  const apiUrl = getApiUrl(hostname);\n\n  return {\n    backend: backend(`${apiUrl}/api/v2`),\n    ...engine(`${apiUrl}/memori/v2`),\n    speech,\n    constants,\n    asset: asset(`${apiUrl}/api/v2`),\n  };\n};\n\nexport default api;\n","import correlationPairs from './engine/correlationPairs';\nimport dialog from './engine/dialog';\nimport importExport from './engine/importExport';\nimport intents from './engine/intents';\nimport localizationKeys from './engine/localizationKeys';\nimport media from './engine/media';\nimport memories from './engine/memories';\nimport nlp from './engine/nlp';\nimport people from './engine/people';\nimport promptedQuestions from './engine/promptedQuestions';\nimport search from './engine/search';\nimport session from './engine/session';\nimport stats from './engine/stats';\nimport unansweredQuestions from './engine/unansweredQuestions';\nimport contextVars from './engine/contextVars';\nimport customDictionary from './engine/customDictionary';\nimport chatLogs from './engine/chatLogs';\n\nexport default (apiUrl: string) => ({\n  correlationPairs: correlationPairs(apiUrl),\n  ...correlationPairs(apiUrl),\n  dialog: dialog(apiUrl),\n  ...dialog(apiUrl),\n  importExport: importExport(apiUrl),\n  ...importExport(apiUrl),\n  intents: intents(apiUrl),\n  ...intents(apiUrl),\n  localizationKeys: localizationKeys(apiUrl),\n  ...localizationKeys(apiUrl),\n  media: media(apiUrl),\n  ...media(apiUrl),\n  memories: memories(apiUrl),\n  ...memories(apiUrl),\n  nlp: nlp(apiUrl),\n  ...nlp(apiUrl),\n  people: people(apiUrl),\n  ...people(apiUrl),\n  promptedQuestions: promptedQuestions(apiUrl),\n  ...promptedQuestions(apiUrl),\n  search: search(apiUrl),\n  ...search(apiUrl),\n  session: session(apiUrl),\n  ...session(apiUrl),\n  stats: stats(apiUrl),\n  ...stats(apiUrl),\n  unansweredQuestions: unansweredQuestions(apiUrl),\n  ...unansweredQuestions(apiUrl),\n  contextVars: contextVars(apiUrl),\n  ...contextVars(apiUrl),\n  customDictionary: customDictionary(apiUrl),\n  ...customDictionary(apiUrl),\n  chatLogs: chatLogs(apiUrl),\n  ...chatLogs(apiUrl),\n});\n"],"names":["apiFetcher","path","opts","fetch","apiUrl","body","JSON","stringify","undefined","mode","credentials","headers","Content-Type","then","res","text","json","getTenantPublicMemoriList","tenant","encodeURI","getPublicMemoriList","authToken","getAllMemori","getUserMemoriList","getSharedMemoriList","getTenantCategories","getMemoriConfigs","createMemori","memori","method","updateMemori","memoriID","deleteMemori","getMemoriById","getMemoriByUserAndId","tenantName","userID","getMemori","userName","memoriName","getMemoriSessions","dateFrom","dateTo","transferMemori","userSignIn","user","userConfirmSignIn","userLogin","userLogout","getUser","getUsersList","deleteUser","updateUser","resetPassword","resetConfirm","recoverUsername","getTenantConfig","resendVerificationCode","createUser","getMemoriIntegrationsList","getAllIntegrationsList","getIntegration","integrationID","deleteIntegration","createIntegration","integration","updateIntegration","getUploadAssetURL","memoryID","uploadAsset","fileName","fileUrl","data","FormData","_context","file","blob","append","upload","getAsset","sessionID","updateAsset","assetURL","asset","split","reverse","deleteAsset","getSentInvitations","getReceivedInvitations","getAllInvitations","getInvitation","invitationId","updateInvitation","invitation","invitationID","deleteInvitation","acceptInvitation","rejectInvitation","sendInvitation","getTenantConsumptionLogs","tenantID","type","getUserConsumptionLogs","getMemoriConsumptionLogs","getTenantNotifications","getUserNotifications","backendAPI","consumptionLogs","notifications","getCorrelationPairs","sessionId","deleteCorrelationPair","pairId","postTextEnteredEvent","postPlaceChangedEvent","placeName","latitude","longitude","uncertaintyKm","postDateChangedEvent","postTagChangedEvent","tag","postTimeoutEvent","postMediumSelectedEvent","medium","postDateSelectedEvent","postPlaceSelectedEvent","postTagSelectedEvent","importCSV","csvRows","params","exportCSV","getIntents","getIntent","intentId","patchIntent","intent","intentID","deleteIntent","createIntent","getIntentSlots","getIntentSlot","slotId","patchIntentSlot","intentSlot","intentSlotID","deleteIntentSlot","createIntentSlot","getLocalizationKeys","getLocalizationKey","key","deleteLocalizationKey","postLocalizationKey","localizationKey","patchLocalizationKey","getMedia","memoryId","deleteMedia","getMedium","mediumId","patchMedium","deleteMedium","postMedium","getMemories","getMemoriesPaginated","from","howMany","getMemory","patchMemory","memory","deleteMemory","postMemory","getMemoryAccess","getWordVector","word","getSimilarWords","guessLanguage","computeSimilarity","referenceText","referenceTextType","comparisonText","comparisonTextType","checkWords","getPeople","getPerson","personId","patchPerson","person","personID","deletePerson","postPerson","getPromptedQuestions","getPromptedQuestion","promptId","patchPromptedQuestion","deletePromptedQuestion","postPromptedQuestion","searchMemory","query","postRandom","postHints","initSession","getSession","deleteSession","getStatistics","getContentQualityIndexes","getTextQualityIndexes","getEventLogs","strDateFrom","strDateTo","getMemoryEventLogs","getIntentEventLogs","getUnansweredQuestions","getUnansweredQuestionsPaginated","deleteUnansweredQuestion","unansweredQuestionId","getContextVars","getContextVarNames","getContextVarValues","contextVarName","getCustomWords","getCustomWord","customWordID","deleteCustomWord","postCustomWord","customWord","patchCustomWord","getChatLogs","deleteChatLogs","deleteChatLog","chatLogId","speech","AZURE_COGNITIVE_SERVICES_TTS_KEY","DEBUG","lang","voiceType","speechSynthesizer","audioDestination","speechConfig","speechSdk","fromSubscription","audioOutputConfig","fromSpeakerOutput","speechSynthesisVoiceName","voice","toUpperCase","getTTSVoice","langCultureCode","getCultureCodeByLanguage","speechSynthesisLanguage","speechRecognitionLanguage","recognizer","stopSpeaking","pause","close","audioInputConfig","fromDefaultMicrophoneInput","stopRecognizing","onStop","stopContinuousRecognitionAsync","speak","onAudioEnd","speakTextAsync","result","console","log","e","error","window","speechSynthesis","SpeechSynthesisUtterance","isSpeaking","recognize","onRecognized","recognizing","_s","recognized","reason","RecognizedSpeech","NoMatch","canceled","Error","errorCode","errorDetails","sessionStopped","_e","startContinuousRecognitionAsync","isRecognizing","getResourceUrl","resourceURI","baseURL","defaultUri","length","includes","startsWith","replace","hostname","URL","origin","getApiUrl","backend","correlationPairs","dialog","importExport","intents","localizationKeys","media","memories","nlp","people","promptedQuestions","search","session","stats","unansweredQuestions","contextVars","customDictionary","chatLogs","engine","constants"],"mappings":"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"}